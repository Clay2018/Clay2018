<!doctype html><html lang=zh-cn data-theme=dark><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.111.3"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="sort algorithm"><meta itemprop=description content="保持简单的易用性和强大的功能。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=keywords content><meta property="og:type" content="article"><meta property="og:title" content="sort algorithm"><meta property="og:description" content="保持简单的易用性和强大的功能。"><meta property="og:image" content="/imgs/hugo_next_avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/sort_algorithm/"><meta property="og:site_name" content="Hugo NexT"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Clayton"><meta property="article:published_time" content="2021-03-22 00:00:44 +0800 CST"><meta property="article:modified_time" content="2021-03-22 00:00:44 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.08ebc9a6fe9879a55c7c23d5568de256dafee7bfce20e8b9f0143807c4cb99e5.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"sort_algorithm","permalink":"/post/sort_algorithm/","title":"sort algorithm","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>sort algorithm - Hugo NexT</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Hugo NexT</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>为 Hugo 打造的主题</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-flinks"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-thumbs-up hvr-icon"></i>站点示例</a></li><li class="menu-item menu-item-archives"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>144</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#排序算法复杂度>排序算法复杂度</a></li><li><a href=#冒泡排序>冒泡排序</a></li><li><a href=#插入排序>插入排序</a></li><li><a href=#希尔排序>希尔排序</a></li><li><a href=#选择排序>选择排序</a></li><li><a href=#堆排序>堆排序</a></li><li><a href=#2-路归并排序>2-路归并排序</a></li><li><a href=#快速排序>快速排序</a></li><li><a href=#20201214>20201214</a></li><li><a href=#reference>Reference</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt="NexT 主题" src=/imgs/img-lazy-loading.gif data-src=/imgs/hugo_next_avatar.png><p class=site-author-name itemprop=name>NexT 主题</p><div class=site-description itemprop=description>保持简单的易用性和强大的功能。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>144</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>10</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>22</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/elkan1788 title="Github → https://github.com/elkan1788" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=https://www.zhihu.com/people/lisenhui title="知乎 → https://www.zhihu.com/people/lisenhui" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=0001-01-01T00:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=72705></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=264></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-08-18T00:47:44+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/sort_algorithm/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=name content="Clayton"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="NexT 主题"><meta itemprop=description content="保持简单的易用性和强大的功能。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="sort algorithm"><meta itemprop=description content="排序算法复杂度 冒泡排序 将第一个数A跟第二个数B相比较，如果A>B，那么交换A，B位置，接下来将第二个数跟第三个数比较 func bubbleSort(array []int) { length := len(array) for i"></span><header class=post-header><h1 class=post-title itemprop="name headline"><span class=post-sticky-flag title=置顶><i class="fa fa-thumbtack"></i>
</span>sort algorithm
<a href=https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/post/sort_algorithm.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2021-03-22 00:00:44 +0800 CST" itemprop="dateCreated datePublished" datetime="2021-03-22 00:00:44 +0800 CST">2021-03-22</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/algorithm itemprop=url rel=index><span itemprop=name>algorithm</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>3234</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>7分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv class=waline-pageview-count data-path=/post/sort_algorithm/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h3 id=排序算法复杂度>排序算法复杂度</h3><p><img src=/post//image/sort_algorithm/sort_algorithm.jpg></p><h3 id=冒泡排序>冒泡排序</h3><p>将第一个数A跟第二个数B相比较，如果A>B，那么交换A，B位置，接下来将第二个数跟第三个数比较</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func bubbleSort(array []int) {
</span></span><span style=display:flex><span>    length := len(array)
</span></span><span style=display:flex><span>    for i := 0; i &lt; length; i++ {
</span></span><span style=display:flex><span>    	for j := 0; j &lt; length-1-i; j++ {
</span></span><span style=display:flex><span>    		if (array[j] &gt; array[j+1]) {
</span></span><span style=display:flex><span>    			array[j], array[j+1] = array[j+1], array[j]
</span></span><span style=display:flex><span>    		}
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第一次遍历, n-1这个数已经有序,第i次遍历，n-1-i后续数已经有序。外围for循环判断式可改为 i &lt;lenght-1,因为当i=length-1时,只剩下第0个数本身，不需要再比较
冒泡排序第一次执行，arr[n-1]为最大数值,较大的数不断往后冒泡。
第i次排序后，[n-i, n-1]有序,如果在第i次中没有发生交换，那么说明整个序列已经有序</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func bubbleSort(array []int) {
</span></span><span style=display:flex><span>length := len(array)
</span></span><span style=display:flex><span>for i := 0; i &lt; length; i++ {
</span></span><span style=display:flex><span>	flag := false
</span></span><span style=display:flex><span>	for j := 0; j &lt; length-1-i; j++ {
</span></span><span style=display:flex><span>		if (array[j] &gt; array[j+1]) {
</span></span><span style=display:flex><span>			array[j], array[j+1] = array[j+1], array[j]
</span></span><span style=display:flex><span>			flag = true
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	if !flag {
</span></span><span style=display:flex><span>		break
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第i次排序后，[n-i, n-1]有序,如果第i次排序中,在[lastPos, n-i]也没有发生交换，那么说明[lastPos, n-1]已经有序，下次循环区间可由[0, n-i-1]变为[0, n-lastPos-1]，缩小了循环空间</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func bubbleSort(array []int) {
</span></span><span style=display:flex><span>    length := len(array)
</span></span><span style=display:flex><span>    for i := 0; i &lt; length; i++ {
</span></span><span style=display:flex><span>    	flag := false
</span></span><span style=display:flex><span>    	lastPos := i
</span></span><span style=display:flex><span>    	tmp := 0
</span></span><span style=display:flex><span>    	for j := 0; j &lt; length-1-lastPos; j++ {
</span></span><span style=display:flex><span>    		if (array[j] &gt; array[j+1]) {
</span></span><span style=display:flex><span>    			array[j], array[j+1] = array[j+1], array[j]
</span></span><span style=display:flex><span>    			flag = true
</span></span><span style=display:flex><span>    			tmp = j
</span></span><span style=display:flex><span>    		}
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>    	lastPos = tmp
</span></span><span style=display:flex><span>    	if !flag {
</span></span><span style=display:flex><span>    		break
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=插入排序>插入排序</h3><p>向一个已经排序的序列中插入一个新值</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func insertSort(array []int) {
</span></span><span style=display:flex><span>    length := len(array)
</span></span><span style=display:flex><span>    for i := 1; i &lt; length; i++ {
</span></span><span style=display:flex><span>    	j := i-1
</span></span><span style=display:flex><span>    	for ; j &gt;= 0; j-- {
</span></span><span style=display:flex><span>    		if array[j] &gt; array[j+1] {
</span></span><span style=display:flex><span>    			array[j], array[j+1] = array[j+1], array[j]
</span></span><span style=display:flex><span>    		}
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>插入排序时间复杂度: 1 + 2 + &mldr; + n = O(n^2),空间复杂度O(1)。它的平均时间复杂度、最差复杂度、最好复杂度都是一样的。
在排序过程中，如果数组元素不与排序规则一致，会导致大量元素交换。对于数组形式没有优化，如果元素以链表形式，那么可以将索引记住，在合适的地方才插入</p><h3 id=希尔排序>希尔排序</h3><p>将整个待排序的记录序列分割成为若干个子序列分别进行直接插入排序
错误实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func shellSort(array []int) {
</span></span><span style=display:flex><span>    length := len(array)
</span></span><span style=display:flex><span>    d := length / 2
</span></span><span style=display:flex><span>    for ; d &gt; 0; d /= 2 {
</span></span><span style=display:flex><span>    	i := d
</span></span><span style=display:flex><span>    	for ; i &lt; length; i += d {
</span></span><span style=display:flex><span>    		j := i - d
</span></span><span style=display:flex><span>    		for ; j &gt;=0; j -=d {
</span></span><span style=display:flex><span>    			if array[j] &gt; array[j+d] {
</span></span><span style=display:flex><span>    				array[j], array[j+d] = array[j+d], array[j]
</span></span><span style=display:flex><span>    			}
</span></span><span style=display:flex><span>    		}
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述实现仅是在插入排序前增加了部分元素的交换，没有运用到分组思想
正确实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func shellSort(array []int) {
</span></span><span style=display:flex><span>    length := len(array)
</span></span><span style=display:flex><span>    d := length / 2
</span></span><span style=display:flex><span>    for ; d &gt; 0; d /= 2 {
</span></span><span style=display:flex><span>    	i := d
</span></span><span style=display:flex><span>    	for ; i &lt; length; i ++ {
</span></span><span style=display:flex><span>    		j := i - d
</span></span><span style=display:flex><span>    		for ; j &gt;=0; j -=d {
</span></span><span style=display:flex><span>    			if array[j] &gt; array[j+d] {
</span></span><span style=display:flex><span>    				array[j], array[j+d] = array[j+d], array[j]
</span></span><span style=display:flex><span>    			}
</span></span><span style=display:flex><span>    		}
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=选择排序>选择排序</h3><pre><code>在一个序列中搜索最小的数，在排除此数的序列中搜索最小的数，如此反复
```
func selectSort(array []int) {
    length := len(array)
    for i := 0; i &lt; length; i++ {
    	minIndex := i
    	for j := i+1; j &lt; length; j++ {
    		if array[minIndex] &gt; array[j] {
    			minIndex = j
    		}
    	}
    	array[i], array[minIndex] = array[minIndex], array[i] }
}
```
选择排序是不稳定的，在交换时相对顺序会更改，例如序列(5, 5, 2, 3)
</code></pre><h3 id=堆排序>堆排序</h3><h3 id=2-路归并排序>2-路归并排序</h3><p>归并排序时一个分治法典型应用，将已有序的子序列合并，得到完全有序的序列。
将长度为n的输入序列分成两个长度为n/2的子序列；对这两个子序列分别采用归并排序；将两个排序好的子序列合并成一个最终的序列
边界条件确定：当子序列有且仅有一个元素时，直接返回子序列</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func merge(array []int, low, mid, high int) {
</span></span><span style=display:flex><span>	var tmp []int
</span></span><span style=display:flex><span>	i, j := low, mid
</span></span><span style=display:flex><span>	for ; i &lt;= mid &amp;&amp; j &lt;= high; {
</span></span><span style=display:flex><span>		if (array[i] &lt; array[j]) {
</span></span><span style=display:flex><span>			tmp = append(tmp, array[i])
</span></span><span style=display:flex><span>			i++
</span></span><span style=display:flex><span>		} else if (array[i] &gt; array[j]) {
</span></span><span style=display:flex><span>			tmp = append(tmp, array[j])
</span></span><span style=display:flex><span>			j++
</span></span><span style=display:flex><span>		} else {
</span></span><span style=display:flex><span>			tmp = append(tmp, array[i])
</span></span><span style=display:flex><span>			tmp = append(tmp, array[j])
</span></span><span style=display:flex><span>			i++
</span></span><span style=display:flex><span>			j++
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	if i &gt; mid {
</span></span><span style=display:flex><span>		tmp = append(tmp, array[j:]...)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	if j &gt; high {
</span></span><span style=display:flex><span>		tmp = append(tmp, array[i:mid+1]...)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	if high-low+1 != len(tmp) {
</span></span><span style=display:flex><span>		printArray(array)
</span></span><span style=display:flex><span>		println(low)
</span></span><span style=display:flex><span>		println(mid)
</span></span><span style=display:flex><span>		println(high)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	for k := 0; k &lt; len(tmp); k++ {
</span></span><span style=display:flex><span>		array[low] = tmp[k]
</span></span><span style=display:flex><span>		low++
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>func mergeSort(array []int, low, high int) {
</span></span><span style=display:flex><span>	if low &gt;= high {
</span></span><span style=display:flex><span>		return
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	mid := (high + low) / 2
</span></span><span style=display:flex><span>	mergeSort(array, low, mid)
</span></span><span style=display:flex><span>	mergeSort(array, mid+1, high)
</span></span><span style=display:flex><span>	merge(array, low, mid, high)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在第一遍实现时，没有注意到merge合并的条件必须时[low,mid]和[mid+1,high]</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func merge(array []int, low, mid, high int) {
</span></span><span style=display:flex><span>    var tmp []int
</span></span><span style=display:flex><span>    i, j := low, mid+1
</span></span><span style=display:flex><span>    for ; i &lt;= mid &amp;&amp; j &lt;= high; {
</span></span><span style=display:flex><span>		if (array[i] &lt; array[j]) {
</span></span><span style=display:flex><span>			tmp = append(tmp, array[i])
</span></span><span style=display:flex><span>			i++
</span></span><span style=display:flex><span>		} else if (array[i] &gt; array[j]) {
</span></span><span style=display:flex><span>			tmp = append(tmp, array[j])
</span></span><span style=display:flex><span>			j++
</span></span><span style=display:flex><span>		} else {
</span></span><span style=display:flex><span>			tmp = append(tmp, array[i])
</span></span><span style=display:flex><span>    			tmp = append(tmp, array[j])
</span></span><span style=display:flex><span>    			i++
</span></span><span style=display:flex><span>    			j++
</span></span><span style=display:flex><span>    		}
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>    	if i &gt; mid &amp;&amp; j &lt;= high{
</span></span><span style=display:flex><span>    		tmp = append(tmp, array[j:high+1]...)
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>    	if j &gt; high &amp;&amp; i &lt;= mid {
</span></span><span style=display:flex><span>    		tmp = append(tmp, array[i:mid+1]...)
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>    	fmt.Println(&#34;--------------------------------&#34;)
</span></span><span style=display:flex><span>    	fmt.Println(array[low:high+1])
</span></span><span style=display:flex><span>    	fmt.Println(low, mid, high)
</span></span><span style=display:flex><span>    	fmt.Println(tmp)
</span></span><span style=display:flex><span>    	fmt.Println(&#34;--------------------------------&#34;)
</span></span><span style=display:flex><span>    for k := 0; k &lt; len(tmp); k++ {
</span></span><span style=display:flex><span>    	array[low] = tmp[k]
</span></span><span style=display:flex><span>    	low++
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    func mergeSort(array []int, low, high int) {
</span></span><span style=display:flex><span>        if low &gt;= high {
</span></span><span style=display:flex><span>            return
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        mid := (high + low) / 2
</span></span><span style=display:flex><span>        mergeSort(array, low, mid)
</span></span><span style=display:flex><span>        mergeSort(array, mid+1, high)
</span></span><span style=display:flex><span>        merge(array, low, mid, high)
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=快速排序>快速排序</h3><p>快速排序同样时运用分治法来排序。从序列中挑出一个元素，称为基准；小于基准值的元素放在左边，大于则放在右边，得到两个序列和一个基准值；对子序列做同样工作；当子序列仅有1个元素或0个时，结束</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func quicSort(array []int, l, r int) {
</span></span><span style=display:flex><span>    if l &gt;= r {
</span></span><span style=display:flex><span>	    return
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	i, j := l, r
</span></span><span style=display:flex><span>	pviot := array[l]
</span></span><span style=display:flex><span>	for ; i &lt;= j; {
</span></span><span style=display:flex><span>		for ; i &lt; j &amp;&amp; array[i] &lt;= pviot; i++ {
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		for ; i &lt; j &amp;&amp; array[j] &gt; pviot; j-- {
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		if i &lt; j {
</span></span><span style=display:flex><span>			array[i], array[j] = array[j], array[i]
</span></span><span style=display:flex><span>            i++
</span></span><span style=display:flex><span>		    j--
</span></span><span style=display:flex><span>		} else {
</span></span><span style=display:flex><span>			break
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	array[i], array[l] = array[l], array[i]
</span></span><span style=display:flex><span>	fmt.Println(&#34;-------------------------------&#34;)
</span></span><span style=display:flex><span>	printArray(array)
</span></span><span style=display:flex><span>	fmt.Println(i, j, l, r)
</span></span><span style=display:flex><span>	fmt.Println(&#34;-------------------------------&#34;)
</span></span><span style=display:flex><span>	quicSort(array, l, i-1)
</span></span><span style=display:flex><span>	quicSort(array, i+1, r)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述算法思路：以pviot（array[l])为基准，从左找小于或等于pviot的数，找到后记下索引i值；从右找大于pviot的数,找到后记下索引j值；如果i &lt; j，那么交换i,j的值；如果 i找到或j找到，但另一个没有找到，此时i==j，跳出循环,将i,l对应值互换（显然，这一步时错误的，如果找到j但没找到i，互换后pviot值左边有一个比它大的数）。
那么，找到索引i值，k := l, 将arr[k] = arr[i]; k = i，留下空位k，找到索引j值，arr[k] = arr[j]; k = j, 索引k一直在区间[i, j]中变动，直到i == j，此时 k == i,将 arr[k] = pviot。之后再快排左右两个子序列。(必须从右边寻找起，因为开始k起始值在左边)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func quicSort(array []int, l, r int) {
</span></span><span style=display:flex><span>	if l &gt;= r {
</span></span><span style=display:flex><span>		return
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	i, j := l, r
</span></span><span style=display:flex><span>	k := l
</span></span><span style=display:flex><span>	pviot := array[l]
</span></span><span style=display:flex><span>	fmt.Println(&#34;++++++++++++++++++++++++++++++++&#34;)
</span></span><span style=display:flex><span>	fmt.Println(i, j, k, pviot)
</span></span><span style=display:flex><span>	for ; i &lt; j; {
</span></span><span style=display:flex><span>		for ; i &lt; j &amp;&amp; array[j] &gt; pviot; j-- {
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		if i &lt; j {
</span></span><span style=display:flex><span>			array[k] = array[j]
</span></span><span style=display:flex><span>			k = j
</span></span><span style=display:flex><span>			j--
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		fmt.Println(array[l:r+1])
</span></span><span style=display:flex><span>		for ; i &lt; j &amp;&amp; array[i] &lt;= pviot; i++ {
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		if i &lt; j {
</span></span><span style=display:flex><span>			array[k] = array[i]
</span></span><span style=display:flex><span>			k = i
</span></span><span style=display:flex><span>			i++
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		fmt.Println(array[l:r+1])
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fmt.Println(&#34;++++++++++++++++++++++++++++++++&#34;)
</span></span><span style=display:flex><span>	array[k] = pviot
</span></span><span style=display:flex><span>	fmt.Println(&#34;----------------------------&#34;)
</span></span><span style=display:flex><span>	fmt.Println(k, i, j)
</span></span><span style=display:flex><span>	fmt.Println(pviot)
</span></span><span style=display:flex><span>	printArray(array)
</span></span><span style=display:flex><span>	fmt.Println(&#34;----------------------------&#34;)
</span></span><span style=display:flex><span>	quicSort(array, l, k-1)
</span></span><span style=display:flex><span>	quicSort(array, k+1, r)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述算法{10, 4, 3}通过,{10, 4, 7,2, 13, 89, 4, 3}没有通。实验数据对比得出，k值变动并不会一直在区间[i,j]，这是因为每次交换数值时，k值会被移动到区间外，发现i &lt; j条件改为 i &lt; k可能可行，理论推导不可行，k值变动中会有如下情况{14, 89, 3}这个序列中k = 0, j = 2, 于是k, j 交换对应值, k=2,此时 元素89不能被移动到k值右边。脑已经有些乱了，推倒重新开始实现</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func quickSort(arr []int, left, right int) {
</span></span><span style=display:flex><span>	if left &gt;= right {
</span></span><span style=display:flex><span>		return
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	//分子序列
</span></span><span style=display:flex><span>	pviot := arr[left]
</span></span><span style=display:flex><span>	i, j := left+1, right
</span></span><span style=display:flex><span>	for ;i &lt; j; {
</span></span><span style=display:flex><span>		for ; i &lt; j &amp;&amp; arr[i] &lt;= pviot; i++ {
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		for ; i &lt; j &amp;&amp; arr[j] &gt; pviot; j-- {
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		if i &lt; j {
</span></span><span style=display:flex><span>			arr[i], arr[j] = arr[j], arr[i]
</span></span><span style=display:flex><span>			i++
</span></span><span style=display:flex><span>			j--
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	if arr[i] &lt;= pviot {
</span></span><span style=display:flex><span>		arr[left], arr[i] = arr[i], arr[left]
</span></span><span style=display:flex><span>	} else {
</span></span><span style=display:flex><span>		for k := left; k &lt; i-1; k++ {
</span></span><span style=display:flex><span>			arr[k] = arr[k+1]
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		i = i-1
</span></span><span style=display:flex><span>		arr[i] = pviot
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	quickSort(arr, left, i-1)
</span></span><span style=display:flex><span>	quickSort(arr, i+1, right)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述实现正确，但i==j这个元素处理会导致过多的数组移动，能否在一开始就将数组移动，那么必须利用空位pviot</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>k := left
</span></span><span style=display:flex><span>for ;i &lt; j; {
</span></span><span style=display:flex><span>	for ; i &lt; j &amp;&amp; arr[i] &lt;= pviot; i++ {
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	for ; i &lt; j &amp;&amp; arr[j] &gt; pviot; j-- {
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	if i &lt; j {
</span></span><span style=display:flex><span>		arr[k] = arr[j]
</span></span><span style=display:flex><span>		arr[j] = arr[i]
</span></span><span style=display:flex><span>		k = i
</span></span><span style=display:flex><span>		i++
</span></span><span style=display:flex><span>		j--
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用k表示空位索引，如果从左找起，找到的i==j值远离k，一样存在区间[k, i]的移动；所以需要从右开始找起,同样会存在[k, i]区间，那么从一遍找起</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func quickSort(arr []int, left, right int) {
</span></span><span style=display:flex><span>	if left &gt;= right {
</span></span><span style=display:flex><span>		return
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	//分子序列
</span></span><span style=display:flex><span>	pviot := arr[right]
</span></span><span style=display:flex><span>	i := left-1
</span></span><span style=display:flex><span>	for j := left; j &lt;= right-1; j++ {
</span></span><span style=display:flex><span>		if arr[j] &lt; pviot {
</span></span><span style=display:flex><span>			i++
</span></span><span style=display:flex><span>			arr[i], arr[j] = arr[j], arr[i]
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	arr[i+1], arr[right] = arr[right], arr[i+1]
</span></span><span style=display:flex><span>	quickSort(arr, left, i)
</span></span><span style=display:flex><span>	quickSort(arr, i+2, right)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述实现如果将pviot := arr[left], j := left+1，此实现如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func quickSort(arr []int, left, right int) {
</span></span><span style=display:flex><span>	if left &gt;= right {
</span></span><span style=display:flex><span>		return
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	//分子序列
</span></span><span style=display:flex><span>	pviot := arr[left]
</span></span><span style=display:flex><span>	i := left
</span></span><span style=display:flex><span>	for j := left+1; j &lt;= right; j++ {
</span></span><span style=display:flex><span>		if arr[j] &lt; pviot {
</span></span><span style=display:flex><span>			i++
</span></span><span style=display:flex><span>			arr[i], arr[j] = arr[j], arr[i]
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	arr[i+1], arr[left] = arr[left], arr[i+1]
</span></span><span style=display:flex><span>	quickSort(arr, left, i)
</span></span><span style=display:flex><span>	quickSort(arr, i+2, right)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>i+1 这一步有可能 i == right,导致数组溢出
请参考
<a href=https://www.cnblogs.com/sunriseblogs/p/10009890.html title=https://www.cnblogs.com/sunriseblogs/p/10009890.html rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://www.cnblogs.com/sunriseblogs/p/10009890.html
<i class="fa fa-external-link-alt"></i></a></p><h3 id=20201214>20201214</h3><ul><li><p>插入排序</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>void insertSort(int arr[], int n) {
</span></span><span style=display:flex><span>    for(int i = 0; i &lt; n-1; i++) {
</span></span><span style=display:flex><span>        int j = i;
</span></span><span style=display:flex><span>        int tmp = arr[j+1];
</span></span><span style=display:flex><span>        for(; j &gt;= 0; j--) {
</span></span><span style=display:flex><span>            if(tmp &gt;= arr[j]) {
</span></span><span style=display:flex><span>                break;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            arr[j+1] = arr[j];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        arr[j+1] = tmp;
</span></span><span style=display:flex><span>        print(arr, n);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>归并排序</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>void merge(int arr[], int low, int mid, int high) {
</span></span><span style=display:flex><span>    int *tmp = new int[high-low+1];
</span></span><span style=display:flex><span>    int i = low, j = mid + 1;
</span></span><span style=display:flex><span>    int k = 0;
</span></span><span style=display:flex><span>    for(; i &lt;= mid &amp;&amp; j &lt;= high;) {
</span></span><span style=display:flex><span>        if(arr[i] &lt; arr[j]) {
</span></span><span style=display:flex><span>            tmp[k++] = arr[i++];
</span></span><span style=display:flex><span>        } else if(arr[i] &gt; arr[j]) {
</span></span><span style=display:flex><span>            tmp[k++] = arr[j++];
</span></span><span style=display:flex><span>        } else {
</span></span><span style=display:flex><span>            tmp[k++] = arr[i++];
</span></span><span style=display:flex><span>            tmp[k++] = arr[j++];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while(i &lt;= mid) {
</span></span><span style=display:flex><span>        tmp[k++] = arr[i++];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    for(int i = low, j = 0; j &lt; k; i++,j++) {
</span></span><span style=display:flex><span>        arr[i] = tmp[j];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void mergeSort(int arr[], int low, int high) {
</span></span><span style=display:flex><span>    if(low &gt;= high) {
</span></span><span style=display:flex><span>        return;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    int mid = low + (high - low)/2;
</span></span><span style=display:flex><span>    mergeSort(arr, low, mid);
</span></span><span style=display:flex><span>    mergeSort(arr, mid+1, high);
</span></span><span style=display:flex><span>    merge(arr, low, mid, high);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>快速排序</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>void Qsort(int arr[], int low, int high) {
</span></span><span style=display:flex><span>    if(high &lt;= low) return;
</span></span><span style=display:flex><span>    int i = low, j = high + 1;
</span></span><span style=display:flex><span>    int key = arr[low];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    while(true) {
</span></span><span style=display:flex><span>        while(arr[++i] &lt; key) {
</span></span><span style=display:flex><span>            if (i == high) {
</span></span><span style=display:flex><span>                break;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        while(arr[--j] &gt; key) {
</span></span><span style=display:flex><span>            if(j == low) {
</span></span><span style=display:flex><span>                break;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        if(i &gt;= j) {
</span></span><span style=display:flex><span>            break;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        swap(arr[i], arr[j]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    swap(arr[j], arr[low]);
</span></span><span style=display:flex><span>    Qsort(arr, low, j-1);
</span></span><span style=display:flex><span>    Qsort(arr, j+1, high);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>冒泡排序</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>void bulbSort(int arr[], int n) {
</span></span><span style=display:flex><span>    int i = 0;
</span></span><span style=display:flex><span>    int len = n-1;
</span></span><span style=display:flex><span>    for(; i &lt; n; i++) {
</span></span><span style=display:flex><span>        int flag = true;
</span></span><span style=display:flex><span>        int tmp;
</span></span><span style=display:flex><span>        for(int j = 0; j &lt; len; j++) {
</span></span><span style=display:flex><span>            if(arr[j] &gt; arr[j+1]) {
</span></span><span style=display:flex><span>                swap(arr[j], arr[j+1]);
</span></span><span style=display:flex><span>                flag = false;
</span></span><span style=display:flex><span>                tmp = j;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        len = tmp;
</span></span><span style=display:flex><span>        if(flag) {
</span></span><span style=display:flex><span>            break;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>基数排序</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>void radixSort(int *arr, int n) {
</span></span><span style=display:flex><span>    int maxBit = 2;
</span></span><span style=display:flex><span>    for(int i = 0; i &lt; maxBit; i++) {
</span></span><span style=display:flex><span>        int buf[10][100] = {0};
</span></span><span style=display:flex><span>        int pow = 1;
</span></span><span style=display:flex><span>        for(int j = 0 ; j &lt; i; j++) {
</span></span><span style=display:flex><span>            pow *= 10;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        for(int i = 0; i &lt; n; i++) {
</span></span><span style=display:flex><span>            int index = (arr[i] / pow) % 10;
</span></span><span style=display:flex><span>            for (int j = 0; j &lt; 100; j++) {
</span></span><span style=display:flex><span>                if (buf[index][j] == 0) {
</span></span><span style=display:flex><span>                    buf[index][j] = arr[i];
</span></span><span style=display:flex><span>                    break;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        for(int i = 9, k = 0; i &gt;= 0; i--) {
</span></span><span style=display:flex><span>            for(int j = 0; j &lt; 100; j++) {
</span></span><span style=display:flex><span>                if(buf[i][j] != 0) {
</span></span><span style=display:flex><span>                    arr[k++] = buf[i][j];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=reference>Reference</h3><ul><li><p>十大经典排序算法(动图演示):
<a href=https://www.cnblogs.com/onepixel/articles/7674659.html title=https://www.cnblogs.com/onepixel/articles/7674659.html rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://www.cnblogs.com/onepixel/articles/7674659.html
<i class="fa fa-external-link-alt"></i></a></p></li><li><p>冒泡排序的改进:
<a href=https://blog.csdn.net/tjunxin/article/details/8711389 title=https://blog.csdn.net/tjunxin/article/details/8711389 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://blog.csdn.net/tjunxin/article/details/8711389
<i class="fa fa-external-link-alt"></i></a></p></li><li><p>归并排序的递归和迭代解法：https://zhuanlan.zhihu.com/p/124356219</p></li><li><p><a href=https://www.geeksforgeeks.org/quick-sort/ title=https://www.geeksforgeeks.org/quick-sort/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://www.geeksforgeeks.org/quick-sort/
<i class="fa fa-external-link-alt"></i></a></p></li><li><p>快速排序:
<a href=https://mp.weixin.qq.com/s/9JScICC2Tgz8vd4OPCzFqQ title=https://mp.weixin.qq.com/s/9JScICC2Tgz8vd4OPCzFqQ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://mp.weixin.qq.com/s/9JScICC2Tgz8vd4OPCzFqQ
<i class="fa fa-external-link-alt"></i></a></p></li><li><p>跳跃表:
<a href=https://mp.weixin.qq.com/s/XY1gPvdV7hWTDYNDDW2zoQ title=https://mp.weixin.qq.com/s/XY1gPvdV7hWTDYNDDW2zoQ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://mp.weixin.qq.com/s/XY1gPvdV7hWTDYNDDW2zoQ
<i class="fa fa-external-link-alt"></i></a></p></li><li><p>希尔排序:
<a href=https://www.cnblogs.com/chengxiao/p/6104371.html title=https://www.cnblogs.com/chengxiao/p/6104371.html rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://www.cnblogs.com/chengxiao/p/6104371.html
<i class="fa fa-external-link-alt"></i></a></p></li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/></a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/image/alipay_qrcode.png alt="NexT 主题 - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/image/wechat_qrcode.png alt="NexT 主题 - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
sort algorithm</li><li class=post-copyright-author><strong>原文作者：</strong>
Clayton</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/sort_algorithm/ title="sort algorithm">/post/sort_algorithm/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i></span>
<span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i></span>
<span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/hashmap_in_golang/ rel=next title=golang哈希表><i class="fa fa-chevron-left"></i> golang哈希表</a></div><div class="post-nav-prev post-nav-item"><a href=/post/binary_search/ rel=prev title=二分查找>二分查找
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>NexT 主题</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.111.3 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.0 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>粤ICP备 18047355-1 号</a>
<img src=/imgs/gongan.png alt=沪公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=31011402009770" target=_blank>沪公网安备 31011402009770 号</a></div><div class=vendors-list><a target=_blank href=https://vercel.com title=Vercel><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/vercel.svg alt=Vercel></a>
<a target=_blank href=https://upyun.com title=又拍云><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/upyun.png alt=又拍云></a>
<a target=_blank href=https://webify.cloudbase.net title=Webify>Webify</a>
<span>提供CDN/云资源支持</span></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.0","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.37028fbafbd97fd89808b4c7b5a3a81f01ed0ab24001d273d774f9546a0e9170.js defer></script></body></html>