<!doctype html><html lang=zh-cn data-theme=dark><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.111.3"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Channel在Go中运用"><meta itemprop=description content="保持简单的易用性和强大的功能。"><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=keywords content="golang"><meta property="og:type" content="article"><meta property="og:title" content="Channel在Go中运用"><meta property="og:description" content="保持简单的易用性和强大的功能。"><meta property="og:image" content="/imgs/hugo_next_avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/the_usage_of_channel_in_go/"><meta property="og:site_name" content="Hugo NexT"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Clayton"><meta property="article:published_time" content="2020-12-10 21:05:24 +0800 CST"><meta property="article:modified_time" content="2020-12-10 21:05:24 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.08ebc9a6fe9879a55c7c23d5568de256dafee7bfce20e8b9f0143807c4cb99e5.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"the_usage_of_channel_in_go","permalink":"/post/the_usage_of_channel_in_go/","title":"Channel在Go中运用","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Channel在Go中运用 - Hugo NexT</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Hugo NexT</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>为 Hugo 打造的主题</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-flinks"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-thumbs-up hvr-icon"></i>站点示例</a></li><li class="menu-item menu-item-archives"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>144</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#basic-usage-of-channel>basic usage of channel</a></li><li><a href=#chan原理实现>chan原理实现</a></li><li><a href=#problem>problem</a></li><li><a href=#reference>reference</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt="NexT 主题" src=/imgs/img-lazy-loading.gif data-src=/imgs/hugo_next_avatar.png><p class=site-author-name itemprop=name>NexT 主题</p><div class=site-description itemprop=description>保持简单的易用性和强大的功能。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>144</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>10</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>22</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/elkan1788 title="Github → https://github.com/elkan1788" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=https://www.zhihu.com/people/lisenhui title="知乎 → https://www.zhihu.com/people/lisenhui" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=0001-01-01T00:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=72705></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=264></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=2023-08-18T00:47:44+08:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/the_usage_of_channel_in_go/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=name content="Clayton"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="NexT 主题"><meta itemprop=description content="保持简单的易用性和强大的功能。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Channel在Go中运用"><meta itemprop=description content="basic usage of channel 使用channel发送接收 package main import &#34;fmt&#34; func main() { jobs := make(chan int, 5) done := make(chan bool) go func() { for { j, more := <-jobs if more { fmt.Println(&#34;received job&#34;, j) } else { fmt.Println(&#34;received all jobs&#34;) done <- true return } } }() for j := 1; j <= 3; j++ {"></span><header class=post-header><h1 class=post-title itemprop="name headline"><span class=post-sticky-flag title=置顶><i class="fa fa-thumbtack"></i>
</span>Channel在Go中运用
<a href=https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/post/the_usage_of_channel_in_go.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2020-12-10 21:05:24 +0800 CST" itemprop="dateCreated datePublished" datetime="2020-12-10 21:05:24 +0800 CST">2020-12-10</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/language itemprop=url rel=index><span itemprop=name>language</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>3316</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>7分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv class=waline-pageview-count data-path=/post/the_usage_of_channel_in_go/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h3 id=basic-usage-of-channel>basic usage of channel</h3><ul><li><p>使用channel发送接收</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>jobs</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>more</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>jobs</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>more</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;received job&#34;</span>, <span style=color:#a6e22e>j</span>)
</span></span><span style=display:flex><span>			} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;received all jobs&#34;</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>j</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>3</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>jobs</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>j</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;sent job&#34;</span>, <span style=color:#a6e22e>j</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;sent all jobs&#34;</span>)
</span></span><span style=display:flex><span>	close(<span style=color:#a6e22e>jobs</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>程序结果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>sent job 1
</span></span><span style=display:flex><span>sent job 2
</span></span><span style=display:flex><span>sent job 3
</span></span><span style=display:flex><span>sent all jobs
</span></span><span style=display:flex><span>received job 1
</span></span><span style=display:flex><span>received job 2
</span></span><span style=display:flex><span>received job 3
</span></span><span style=display:flex><span>received all jobs
</span></span></code></pre></div></li><li><p>往一个已关闭的channel中发送数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>SetFlags</span>(<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>LstdFlags</span> | <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Lshortfile</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> recover()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>	close(<span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>往一个已经关闭的channel中发送数据会panic</p></li><li><p>往一个已关闭的channel中读取数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>SetFlags</span>(<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>LstdFlags</span> | <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Lshortfile</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> recover()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>	close(<span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ret</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ret</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>向一个已关闭的channel中读取数据，会马上返回channel中的值(如果没有即类型初值)，不会panic</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>SetFlags</span>(<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>LstdFlags</span> | <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Lshortfile</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> recover()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	close(<span style=color:#a6e22e>done</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ret</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ret</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h3 id=chan原理实现>chan原理实现</h3><ul><li><p>chan结构</p><p>src/runtime/chan.go</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>type hchan struct {
</span></span><span style=display:flex><span>	qcount   uint           // total data in the queue
</span></span><span style=display:flex><span>	dataqsiz uint           // size of the circular queue
</span></span><span style=display:flex><span>	buf      unsafe.Pointer // points to an array of dataqsiz elements
</span></span><span style=display:flex><span>	elemsize uint16
</span></span><span style=display:flex><span>	closed   uint32
</span></span><span style=display:flex><span>	elemtype *_type // element type
</span></span><span style=display:flex><span>	sendx    uint   // send index
</span></span><span style=display:flex><span>	recvx    uint   // receive index
</span></span><span style=display:flex><span>	recvq    waitq  // list of recv waiters
</span></span><span style=display:flex><span>	sendq    waitq  // list of send waiters
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// lock protects all fields in hchan, as well as several
</span></span><span style=display:flex><span>	// fields in sudogs blocked on this channel.
</span></span><span style=display:flex><span>	//
</span></span><span style=display:flex><span>	// Do not change another G&#39;s status while holding this lock
</span></span><span style=display:flex><span>	// (in particular, do not ready a G), as this can deadlock
</span></span><span style=display:flex><span>	// with stack shrinking.
</span></span><span style=display:flex><span>	lock mutex
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type waitq struct {
</span></span><span style=display:flex><span>	first *sudog
</span></span><span style=display:flex><span>	last  *sudog
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>buf指向dataqsiz元素数组，指向环形队列；qcount是队列中的总数据；datasiz是环形队列的大小;如果是带缓冲区的chan，则缓冲区实际是紧跟着hchan结构体分配的</p><p><img src=/post/image/the_usage_of_channel_in_go/b.jpg></p></li><li><p>创建chan</p><p>chan由make创建，Go语言在编译期间的类型检查阶段将代表make关键字的OMAKE节点根据参数类型的不同转换成了OMAKESLICE、OMAKEMAP和OMAKECHAN三种不同类型的节点，这些节点会调用不同的运行时函数来初始化相应的数据结构。而chan类型则调用 makechan() ，如下(src/runtime/chan.go)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func makechan(t *chantype, size int) *hchan {
</span></span><span style=display:flex><span>	elem := t.elem
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// compiler checks this but be safe.
</span></span><span style=display:flex><span>	if elem.size &gt;= 1&lt;&lt;16 {
</span></span><span style=display:flex><span>		throw(&#34;makechan: invalid channel element type&#34;)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	if hchanSize%maxAlign != 0 || elem.align &gt; maxAlign {
</span></span><span style=display:flex><span>		throw(&#34;makechan: bad alignment&#34;)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	mem, overflow := math.MulUintptr(elem.size, uintptr(size))
</span></span><span style=display:flex><span>	if overflow || mem &gt; maxAlloc-hchanSize || size &lt; 0 {
</span></span><span style=display:flex><span>		panic(plainError(&#34;makechan: size out of range&#34;))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// Hchan does not contain pointers interesting for GC when elements stored in buf do not    contain pointers.
</span></span><span style=display:flex><span>	// buf points into the same allocation, elemtype is persistent.
</span></span><span style=display:flex><span>	// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span></span><span style=display:flex><span>	// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span></span><span style=display:flex><span>	var c *hchan
</span></span><span style=display:flex><span>	switch {
</span></span><span style=display:flex><span>	case mem == 0:
</span></span><span style=display:flex><span>		// Queue or element size is zero.
</span></span><span style=display:flex><span>		c = (*hchan)(mallocgc(hchanSize, nil, true))
</span></span><span style=display:flex><span>		// Race detector uses this location for synchronization.
</span></span><span style=display:flex><span>		c.buf = c.raceaddr()
</span></span><span style=display:flex><span>	case elem.ptrdata == 0:
</span></span><span style=display:flex><span>		// Elements do not contain pointers.
</span></span><span style=display:flex><span>		// Allocate hchan and buf in one call.
</span></span><span style=display:flex><span>		c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
</span></span><span style=display:flex><span>		c.buf = add(unsafe.Pointer(c), hchanSize)
</span></span><span style=display:flex><span>	default:
</span></span><span style=display:flex><span>		// Elements contain pointers.
</span></span><span style=display:flex><span>		c = new(hchan)
</span></span><span style=display:flex><span>		c.buf = mallocgc(mem, elem, true)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	c.elemsize = uint16(elem.size)
</span></span><span style=display:flex><span>	c.elemtype = elem
</span></span><span style=display:flex><span>	c.dataqsiz = uint(size)
</span></span><span style=display:flex><span>	lockInit(&amp;c.lock, lockRankHchan)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if debugChan {
</span></span><span style=display:flex><span>		print(&#34;makechan: chan=&#34;, c, &#34;; elemsize=&#34;, elem.size, &#34;; dataqsiz=&#34;, size, &#34;\n&#34;)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	return c
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>声明一个hchan指针，如果是无缓冲chan，使用<strong>mallocgc</strong>分配；如果chan元素类型为指针，同时为chan和chan元素分配一块连续的内存；默认使用<strong>new</strong>分配chan，用<strong>mallocgc</strong>分配chan元素</p></li><li><p>发送chan</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
</span></span><span style=display:flex><span>	if c == nil {
</span></span><span style=display:flex><span>		if !block {
</span></span><span style=display:flex><span>			return false
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)
</span></span><span style=display:flex><span>		throw(&#34;unreachable&#34;)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if debugChan {
</span></span><span style=display:flex><span>		print(&#34;chansend: chan=&#34;, c, &#34;\n&#34;)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if raceenabled {
</span></span><span style=display:flex><span>		racereadpc(c.raceaddr(), callerpc, funcPC(chansend))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// Fast path: check for failed non-blocking operation without acquiring the lock.
</span></span><span style=display:flex><span>	//
</span></span><span style=display:flex><span>	// After observing that the channel is not closed, we observe that the channel is
</span></span><span style=display:flex><span>	// not ready for sending. Each of these observations is a single word-sized read
</span></span><span style=display:flex><span>	// (first c.closed and second full()).
</span></span><span style=display:flex><span>	// Because a closed channel cannot transition from &#39;ready for sending&#39; to
</span></span><span style=display:flex><span>	// &#39;not ready for sending&#39;, even if the channel is closed between the two observations,
</span></span><span style=display:flex><span>	// they imply a moment between the two when the channel was both not yet closed
</span></span><span style=display:flex><span>	// and not ready for sending. We behave as if we observed the channel at that moment,
</span></span><span style=display:flex><span>	// and report that the send cannot proceed.
</span></span><span style=display:flex><span>	//
</span></span><span style=display:flex><span>	// It is okay if the reads are reordered here: if we observe that the channel is not
</span></span><span style=display:flex><span>	// ready for sending and then observe that it is not closed, that implies that the
</span></span><span style=display:flex><span>	// channel wasn&#39;t closed during the first observation. However, nothing here
</span></span><span style=display:flex><span>	// guarantees forward progress. We rely on the side effects of lock release in
</span></span><span style=display:flex><span>	// chanrecv() and closechan() to update this thread&#39;s view of c.closed and full().
</span></span><span style=display:flex><span>	if !block &amp;&amp; c.closed == 0 &amp;&amp; full(c) {
</span></span><span style=display:flex><span>		return false
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	var t0 int64
</span></span><span style=display:flex><span>	if blockprofilerate &gt; 0 {
</span></span><span style=display:flex><span>		t0 = cputicks()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	lock(&amp;c.lock)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if c.closed != 0 {
</span></span><span style=display:flex><span>		unlock(&amp;c.lock)
</span></span><span style=display:flex><span>		panic(plainError(&#34;send on closed channel&#34;))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if sg := c.recvq.dequeue(); sg != nil {
</span></span><span style=display:flex><span>		// Found a waiting receiver. We pass the value we want to send
</span></span><span style=display:flex><span>		// directly to the receiver, bypassing the channel buffer (if any).
</span></span><span style=display:flex><span>		send(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)
</span></span><span style=display:flex><span>		return true
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if c.qcount &lt; c.dataqsiz {
</span></span><span style=display:flex><span>		// Space is available in the channel buffer. Enqueue the element to send.
</span></span><span style=display:flex><span>		qp := chanbuf(c, c.sendx)
</span></span><span style=display:flex><span>		if raceenabled {
</span></span><span style=display:flex><span>			raceacquire(qp)
</span></span><span style=display:flex><span>			racerelease(qp)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		typedmemmove(c.elemtype, qp, ep)
</span></span><span style=display:flex><span>		c.sendx++
</span></span><span style=display:flex><span>		if c.sendx == c.dataqsiz {
</span></span><span style=display:flex><span>			c.sendx = 0
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		c.qcount++
</span></span><span style=display:flex><span>		unlock(&amp;c.lock)
</span></span><span style=display:flex><span>		return true
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if !block {
</span></span><span style=display:flex><span>		unlock(&amp;c.lock)
</span></span><span style=display:flex><span>		return false
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// Block on the channel. Some receiver will complete our operation for us.
</span></span><span style=display:flex><span>	gp := getg()
</span></span><span style=display:flex><span>	mysg := acquireSudog()
</span></span><span style=display:flex><span>	mysg.releasetime = 0
</span></span><span style=display:flex><span>	if t0 != 0 {
</span></span><span style=display:flex><span>		mysg.releasetime = -1
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	// No stack splits between assigning elem and enqueuing mysg
</span></span><span style=display:flex><span>	// on gp.waiting where copystack can find it.
</span></span><span style=display:flex><span>	mysg.elem = ep
</span></span><span style=display:flex><span>	mysg.waitlink = nil
</span></span><span style=display:flex><span>	mysg.g = gp
</span></span><span style=display:flex><span>	mysg.isSelect = false
</span></span><span style=display:flex><span>	mysg.c = c
</span></span><span style=display:flex><span>	gp.waiting = mysg
</span></span><span style=display:flex><span>	gp.param = nil
</span></span><span style=display:flex><span>	c.sendq.enqueue(mysg)
</span></span><span style=display:flex><span>	gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)
</span></span><span style=display:flex><span>	// Ensure the value being sent is kept alive until the
</span></span><span style=display:flex><span>	// receiver copies it out. The sudog has a pointer to the
</span></span><span style=display:flex><span>	// stack object, but sudogs aren&#39;t considered as roots of the
</span></span><span style=display:flex><span>	// stack tracer.
</span></span><span style=display:flex><span>	KeepAlive(ep)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// someone woke us up.
</span></span><span style=display:flex><span>	if mysg != gp.waiting {
</span></span><span style=display:flex><span>		throw(&#34;G waiting list is corrupted&#34;)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	gp.waiting = nil
</span></span><span style=display:flex><span>	gp.activeStackChans = false
</span></span><span style=display:flex><span>	if gp.param == nil {
</span></span><span style=display:flex><span>		if c.closed == 0 {
</span></span><span style=display:flex><span>			throw(&#34;chansend: spurious wakeup&#34;)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		panic(plainError(&#34;send on closed channel&#34;))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	gp.param = nil
</span></span><span style=display:flex><span>	if mysg.releasetime &gt; 0 {
</span></span><span style=display:flex><span>		blockevent(mysg.releasetime-t0, 2)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	mysg.c = nil
</span></span><span style=display:flex><span>	releaseSudog(mysg)
</span></span><span style=display:flex><span>	return true
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>发送时，先进行加锁，判断recvq队列是否有receivers，如果有则直接将元素拷贝到接收者的go协程的mem中，使用goready唤醒接收者所在协程</p><p>如果是recvq队列没有接收者，有缓存队列首先计算一个可以放置待处理变量的位置，然后通过<strong>typedmemmove</strong>将元素拷贝到所在位置，更新sendx和qcount，释放锁</p><p>无缓冲队列阻塞发送操作: 调用<strong>getg</strong>获取发送操作的协程；执行<strong>acquireSudog</strong>获取一个<strong>sudog</strong>结构体并设置这一次阻塞发送的相关信息;在当前channel的sendq队列中将刚刚创建并初始化的sudog结构体加入等待队列；调用<strong>goparkunlock</strong>函数将当前的goroutine更新成<strong>gwaiting</strong>状态并解锁，该goroutine可以被调用goready再次唤醒;当前的gouroutine在此陷入阻塞状态</p><p>梳理下向channel发送数据时遇到的几种情况:</p><ul><li>如果当前channel的recvq上已存在被阻塞的goroutine，那么会直接将数据发送给当前的goroutine并将其设置成下一个运行的协程；</li><li>如果channel存在缓冲区并且其中还有空闲的容量，我们就会直接将数据存储到当前缓冲区sendx所在位置</li><li>如果都不满足上面的两种情况，就会创建一个sudog结构并加入channel的sendq队列，同时当前的goroutine就会陷入阻塞等待其它的协程向channel中发送数据</li></ul></li><li><p>chan接收</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>    func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
</span></span><span style=display:flex><span>	// raceenabled: don&#39;t need to check ep, as it is always on the stack
</span></span><span style=display:flex><span>	// or is new memory allocated by reflect.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if debugChan {
</span></span><span style=display:flex><span>		print(&#34;chanrecv: chan=&#34;, c, &#34;\n&#34;)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if c == nil {
</span></span><span style=display:flex><span>		if !block {
</span></span><span style=display:flex><span>			return
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)
</span></span><span style=display:flex><span>		throw(&#34;unreachable&#34;)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// Fast path: check for failed non-blocking operation without acquiring the lock.
</span></span><span style=display:flex><span>	if !block &amp;&amp; empty(c) {
</span></span><span style=display:flex><span>		// After observing that the channel is not ready for receiving, we observe whether the
</span></span><span style=display:flex><span>		// channel is closed.
</span></span><span style=display:flex><span>		//
</span></span><span style=display:flex><span>		// Reordering of these checks could lead to incorrect behavior when racing with a   close.
</span></span><span style=display:flex><span>		// For example, if the channel was open and not empty, was closed, and then drained,
</span></span><span style=display:flex><span>		// reordered reads could incorrectly indicate &#34;open and empty&#34;. To prevent reordering,
</span></span><span style=display:flex><span>		// we use atomic loads for both checks, and rely on emptying and closing to happen in
</span></span><span style=display:flex><span>		// separate critical sections under the same lock.  This assumption fails when closing
</span></span><span style=display:flex><span>		// an unbuffered channel with a blocked send, but that is an error condition anyway.
</span></span><span style=display:flex><span>		if atomic.Load(&amp;c.closed) == 0 {
</span></span><span style=display:flex><span>			// Because a channel cannot be reopened, the later observation of the channel
</span></span><span style=display:flex><span>			// being not closed implies that it was also not closed at the moment of the
</span></span><span style=display:flex><span>			// first observation. We behave as if we observed the channel at that moment
</span></span><span style=display:flex><span>			// and report that the receive cannot proceed.
</span></span><span style=display:flex><span>			return
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		// The channel is irreversibly closed. Re-check whether the channel has any pending     data
</span></span><span style=display:flex><span>		// to receive, which could have arrived between the empty and closed checks above.
</span></span><span style=display:flex><span>		// Sequential consistency is also required here, when racing with such a send.
</span></span><span style=display:flex><span>		if empty(c) {
</span></span><span style=display:flex><span>			// The channel is irreversibly closed and empty.
</span></span><span style=display:flex><span>			if raceenabled {
</span></span><span style=display:flex><span>				raceacquire(c.raceaddr())
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			if ep != nil {
</span></span><span style=display:flex><span>				typedmemclr(c.elemtype, ep)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			return true, false
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	var t0 int64
</span></span><span style=display:flex><span>	if blockprofilerate &gt; 0 {
</span></span><span style=display:flex><span>		t0 = cputicks()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	lock(&amp;c.lock)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if c.closed != 0 &amp;&amp; c.qcount == 0 {
</span></span><span style=display:flex><span>		if raceenabled {
</span></span><span style=display:flex><span>			raceacquire(c.raceaddr())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		unlock(&amp;c.lock)
</span></span><span style=display:flex><span>		if ep != nil {
</span></span><span style=display:flex><span>			typedmemclr(c.elemtype, ep)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		return true, false
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if sg := c.sendq.dequeue(); sg != nil {
</span></span><span style=display:flex><span>		// Found a waiting sender. If buffer is size 0, receive value
</span></span><span style=display:flex><span>		// directly from sender. Otherwise, receive from head of queue
</span></span><span style=display:flex><span>		// and add sender&#39;s value to the tail of the queue (both map to
</span></span><span style=display:flex><span>		// the same buffer slot because the queue is full).
</span></span><span style=display:flex><span>		recv(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)
</span></span><span style=display:flex><span>		return true, true
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if c.qcount &gt; 0 {
</span></span><span style=display:flex><span>		// Receive directly from queue
</span></span><span style=display:flex><span>		qp := chanbuf(c, c.recvx)
</span></span><span style=display:flex><span>		if raceenabled {
</span></span><span style=display:flex><span>			raceacquire(qp)
</span></span><span style=display:flex><span>			racerelease(qp)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		if ep != nil {
</span></span><span style=display:flex><span>			typedmemmove(c.elemtype, ep, qp)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		typedmemclr(c.elemtype, qp)
</span></span><span style=display:flex><span>		c.recvx++
</span></span><span style=display:flex><span>		if c.recvx == c.dataqsiz {
</span></span><span style=display:flex><span>			c.recvx = 0
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		c.qcount--
</span></span><span style=display:flex><span>		unlock(&amp;c.lock)
</span></span><span style=display:flex><span>		return true, true
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	if !block {
</span></span><span style=display:flex><span>		unlock(&amp;c.lock)
</span></span><span style=display:flex><span>		return false, false
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// no sender available: block on this channel.
</span></span><span style=display:flex><span>	gp := getg()
</span></span><span style=display:flex><span>	mysg := acquireSudog()
</span></span><span style=display:flex><span>	mysg.releasetime = 0
</span></span><span style=display:flex><span>	if t0 != 0 {
</span></span><span style=display:flex><span>		mysg.releasetime = -1
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	// No stack splits between assigning elem and enqueuing mysg
</span></span><span style=display:flex><span>	// on gp.waiting where copystack can find it.
</span></span><span style=display:flex><span>	mysg.elem = ep
</span></span><span style=display:flex><span>	mysg.waitlink = nil
</span></span><span style=display:flex><span>	gp.waiting = mysg
</span></span><span style=display:flex><span>	mysg.g = gp
</span></span><span style=display:flex><span>	mysg.isSelect = false
</span></span><span style=display:flex><span>	mysg.c = c
</span></span><span style=display:flex><span>	gp.param = nil
</span></span><span style=display:flex><span>	c.recvq.enqueue(mysg)
</span></span><span style=display:flex><span>	gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv,  2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// someone woke us up
</span></span><span style=display:flex><span>	if mysg != gp.waiting {
</span></span><span style=display:flex><span>		throw(&#34;G waiting list is corrupted&#34;)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	gp.waiting = nil
</span></span><span style=display:flex><span>	gp.activeStackChans = false
</span></span><span style=display:flex><span>	if mysg.releasetime &gt; 0 {
</span></span><span style=display:flex><span>		blockevent(mysg.releasetime-t0, 2)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	closed := gp.param == nil
</span></span><span style=display:flex><span>	gp.param = nil
</span></span><span style=display:flex><span>	mysg.c = nil
</span></span><span style=display:flex><span>	releaseSudog(mysg)
</span></span><span style=display:flex><span>	return true, !closed
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接收时，先进行枷锁，判断sendq队列是否有senders，如果有则直接将send队列中的拷贝到接收者目标内存地址中（如果当前channel已经满了，通过<strong>typedmemmove</strong>将队列中的数据拷贝到接收方的内存地址中并将发送方的数据拷贝到队列中，释放一个发送方协程)。</p><p>与<strong>select</strong>语句结合使用时可能会使用到非阻塞<strong>block=false</strong>的接收操作</p><p>梳理下向channel接收数据时遇到的几种情况:</p><ul><li>如果channel是空的，那么会直接调用<strong>gopark</strong>挂起当前的goroutine</li><li>如果channel已经关闭并且缓冲区没有任何数据，chanrecv函数就会直接返回</li><li>如果channel的sendq队列中存在观其的goroutine，就会将recvx索引所在数据拷贝到接收变量所在的内存空间上并将sendq队列中goroutine的数据拷贝到缓冲区中</li><li>如果channel的缓冲区包含数据就会直接从recvx所在索引上进行读取</li><li>在默认情况下会直接挂起当前的goroutine，将sudog结构加入recvq队列并等待调度器唤醒</li></ul></li></ul><h3 id=problem>problem</h3><ul><li><p>chan结构为何是环形队列而不是队列，有什么优势?</p><p>循环队列的出队操作时间为O(1),而队列为O(n)</p></li></ul><h3 id=reference>reference</h3><ul><li><a href=https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/ title=https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-typecheck/
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://juejin.cn/post/6844903806082220046 title=https://juejin.cn/post/6844903806082220046 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://juejin.cn/post/6844903806082220046
<i class="fa fa-external-link-alt"></i></a></li><li>调试+图解 channel 的内部实现:
<a href=https://mp.weixin.qq.com/s/01Hl_eOAP_k_YDTNFErTJQ title=https://mp.weixin.qq.com/s/01Hl_eOAP_k_YDTNFErTJQ rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://mp.weixin.qq.com/s/01Hl_eOAP_k_YDTNFErTJQ
<i class="fa fa-external-link-alt"></i></a></li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/golang>golang</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/image/alipay_qrcode.png alt="NexT 主题 - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/image/wechat_qrcode.png alt="NexT 主题 - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
Channel在Go中运用</li><li class=post-copyright-author><strong>原文作者：</strong>
Clayton</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/the_usage_of_channel_in_go/ title=Channel在Go中运用>/post/the_usage_of_channel_in_go/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i></span>
<span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i></span>
<span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/cloud_storage/ rel=next title="Cloud Storage"><i class="fa fa-chevron-left"></i> Cloud Storage</a></div><div class="post-nav-prev post-nav-item"><a href=/post/celerynote/ rel=prev title=Celery笔记>Celery笔记
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>NexT 主题</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.111.3 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.0 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>粤ICP备 18047355-1 号</a>
<img src=/imgs/gongan.png alt=沪公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=31011402009770" target=_blank>沪公网安备 31011402009770 号</a></div><div class=vendors-list><a target=_blank href=https://vercel.com title=Vercel><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/vercel.svg alt=Vercel></a>
<a target=_blank href=https://upyun.com title=又拍云><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/upyun.png alt=又拍云></a>
<a target=_blank href=https://webify.cloudbase.net title=Webify>Webify</a>
<span>提供CDN/云资源支持</span></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":true,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.0","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":true,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.37028fbafbd97fd89808b4c7b5a3a81f01ed0ab24001d273d774f9546a0e9170.js defer></script></body></html>