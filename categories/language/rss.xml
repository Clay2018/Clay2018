<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>language on Hugo NexT</title><link>/categories/language/</link><description>Recent content in language on Hugo NexT</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 02 May 2022 00:05:24 +0800</lastBuildDate><atom:link href="/categories/language/rss.xml" rel="self" type="application/rss+xml"/><item><title>Go mod</title><link>/post/go_mod/</link><pubDate>Mon, 02 May 2022 00:05:24 +0800</pubDate><guid>/post/go_mod/</guid><description>Resource go mod使用: https://www.jianshu.com/p/760c97ff644c https://liujiacai.net/blog/2019/10/24/go-modules/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io 发展历史 GOPATH go env -w GO111MODULE=&amp;#34;off&amp;#34; GOROOT=/usr/local/go GOPATH=/home/dev/project/go /* 按如下路径+导包路径寻找所需要的包 /usr/local/go/src/ */ go build main.go go编译项目时，只会在GOROOT和GOPATH下找</description></item><item><title>mem alloc in golang</title><link>/post/mem_alloc_in_golang/</link><pubDate>Wed, 06 Apr 2022 01:01:00 +0800</pubDate><guid>/post/mem_alloc_in_golang/</guid><description>memory allocate in golang Resource https://tonybai.com/2020/03/10/visualizing-memory-management-in-golang/ Golang什么时候会触发GC: https://www.jianshu.com/p/96a52a8127d9</description></item><item><title>runtime in golang</title><link>/post/runtime_in_golang/</link><pubDate>Sat, 26 Feb 2022 00:47:44 +0800</pubDate><guid>/post/runtime_in_golang/</guid><description>Resource 聊聊什么是Go runtime.KeepAlive: https://developer.51cto.com/article/692468.html runtime.SetFinalizer https://zhuanlan.zhihu.com/p/76504936 https://www.cnblogs.com/binHome/p/12901392.html</description></item><item><title>version change in golang</title><link>/post/version_change_in_golang/</link><pubDate>Tue, 15 Feb 2022 00:47:44 +0800</pubDate><guid>/post/version_change_in_golang/</guid><description>Go1.14 本次更新大多数变化在于工具链的实现，runtime和libraries defer性能提升 在Go1.14之前，Go中的每一个defer函数，</description></item><item><title>C++ 类</title><link>/post/virtual_func_in_c_plus_plus/</link><pubDate>Mon, 14 Feb 2022 00:47:44 +0800</pubDate><guid>/post/virtual_func_in_c_plus_plus/</guid><description>Resource C++对象布局: https://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&amp;mid=2247484758&amp;idx=1&amp;sn=4e614430f666f63ab135c13a716d07c1&amp;chksm=c21d37eaf56abefc8d2a1dc3e09a8146d242475cb0900ee5a94ab6a94a991168a887f7351821&amp;scene=178&amp;cur_album_id=1667018561883570181#rd</description></item><item><title>C++11 new feature</title><link>/post/c++11_new_feature/</link><pubDate>Mon, 14 Feb 2022 00:47:44 +0800</pubDate><guid>/post/c++11_new_feature/</guid><description>Resource c++11新特性，所有知识点都在这里了: https://mp.weixin.qq.com/s/kAH-402oYgAa3GAVgJ8EaQ</description></item><item><title>io.WriteString()分析</title><link>/post/io_write_string_analysis/</link><pubDate>Sun, 09 Jan 2022 00:45:44 +0800</pubDate><guid>/post/io_write_string_analysis/</guid><description>问题 内存管理在Golang中是棘手的，我们可能相信golang本身已具备内存自动管理功能，可以从此解放出来。但上周的某个功能测试结果让我改变</description></item><item><title>pprof in golang</title><link>/post/pprof_in_golang/</link><pubDate>Sun, 09 Jan 2022 00:45:44 +0800</pubDate><guid>/post/pprof_in_golang/</guid><description>CPU pprof package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; _ &amp;#34;net/http/pprof&amp;#34; &amp;#34;time&amp;#34; ) func main() { go func() { ticker := time.NewTicker(time.Second) for { select { case t := &amp;lt;- ticker.C: fmt.Println(&amp;#34;Current time:&amp;#34;, t) default: } } }() http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil) } #cmdline go run main.go go tool pprof http://127.0.0.1:8080/debug/pprof/profile?seconds=10 go tool pprof -http=:8080 pprof.main.samples.cpu.001.pb.gz Resources pprof: https://go.dev/blog/pprof 使用pprof排查内存泄漏:</description></item><item><title>panic in golang</title><link>/post/panic_in_golang/</link><pubDate>Sun, 05 Sep 2021 00:47:44 +0800</pubDate><guid>/post/panic_in_golang/</guid><description>Resources panic的三种触发方式: https://mp.weixin.qq.com/s/cs_jLLoaq4rweVYFbeJoFw panic实现: https://mp.weixin.qq.com/s/-tYjR9K6tWG3aNOeGFsT3Q</description></item><item><title>sync in golang</title><link>/post/sync_in_golang/</link><pubDate>Sun, 05 Sep 2021 00:47:44 +0800</pubDate><guid>/post/sync_in_golang/</guid><description>Resources sync.Once sync.Once()的妙用: https://mp.weixin.qq.com/s/7QyQS9DQj1czA6BVR6ywYA sync.Once()实现原理: https://segmentfault.com/a/1190000039294152 sync.WaitGroup()的实现原理: https://zhuanlan.zhihu.com/p/344973865</description></item><item><title>interface in golang</title><link>/post/interface_in_golang/</link><pubDate>Tue, 31 Aug 2021 00:00:24 +0800</pubDate><guid>/post/interface_in_golang/</guid><description>Resources []int能转换为[]interface吗: https://mp.weixin.qq.com/s/tqR5zMPobm20lao-2QNrVA</description></item><item><title>Sync map在Go中运用</title><link>/post/sync_map_in_go/</link><pubDate>Wed, 04 Aug 2021 23:05:24 +0800</pubDate><guid>/post/sync_map_in_go/</guid><description>Resource Go sync map 的内部实现: https://mp.weixin.qq.com/s/TGBSUYLiuBaoi3pNbN0BOQ sync map详解: https://blog.csdn.net/a348752377/article/details/104972194 RWMutex内部实现: https://sreramk.medium.com/go-sync-rwmutex-internals-and-usage-explained-9eb15865bba</description></item><item><title>Go中的map</title><link>/post/map_in_golang/</link><pubDate>Mon, 19 Jul 2021 00:00:44 +0800</pubDate><guid>/post/map_in_golang/</guid><description>Resource map中的删除: https://mp.weixin.qq.com/s/fTyfcBhRGNo3Q3Gl12_XNw</description></item><item><title>Go语言的优势和劣势</title><link>/post/advantages_and_disadvantages_in_go/</link><pubDate>Wed, 07 Jul 2021 01:01:00 +0800</pubDate><guid>/post/advantages_and_disadvantages_in_go/</guid><description>Resources GopherChina 2021 Ian说完整泛型实现将在Go1.18发布(会议实录): https://mp.weixin.qq.com/s/RFfa-A0DomH2pXz4arAVnA</description></item><item><title>Scheduling in Golang</title><link>/post/schdule_in_golang/</link><pubDate>Tue, 29 Jun 2021 00:47:44 +0800</pubDate><guid>/post/schdule_in_golang/</guid><description>gopark and goready https://blog.csdn.net/u010853261/article/details/85887948</description></item><item><title>Golang语言遇到的bug</title><link>/post/bug_in_golang/</link><pubDate>Sun, 27 Jun 2021 00:00:44 +0800</pubDate><guid>/post/bug_in_golang/</guid><description>Resource 分析Go time.After 引起内存暴增OOM问题: https://mp.weixin.qq.com/s/jaIdqF0bFpHz_eyPsHjbwQ Go gctrace 引起runtime 调度阻塞: https://mp.weixin.qq.com/s/eHEvVzmpPYXAQgcdd_B55w 高并发场景下 disk io 引发的高时延问题: https://mp.weixin.qq.com/s/e3peaNGwIuNkldvnP0pDug 一个日志打点引发的OOM: https://mp.weixin.qq.com/s/8puLJSJ3GeXnmDlMxdzGgQ 为什</description></item><item><title>Go中的init函数</title><link>/post/init_in_golang/</link><pubDate>Sun, 27 Jun 2021 00:00:44 +0800</pubDate><guid>/post/init_in_golang/</guid><description>Resource init函数: https://studygolang.com/articles/13865?fr=sidebar</description></item><item><title>alloc in golang</title><link>/post/alloc_in_golang/</link><pubDate>Sat, 05 Jun 2021 00:00:44 +0800</pubDate><guid>/post/alloc_in_golang/</guid><description>Resource Go内存管理: https://mp.weixin.qq.com/s/PNRhtdS_gZVTtrkkRmx7yA Go内存管理和分配: https://mp.weixin.qq.com/s/6jAVPSnw5UPotCg40CAB8Q</description></item><item><title>escape in golang</title><link>/post/escape_in_golang/</link><pubDate>Sat, 05 Jun 2021 00:00:44 +0800</pubDate><guid>/post/escape_in_golang/</guid><description>Resource 通过Golang内存逃逸分析讨论GC的压力: https://www.jianshu.com/p/10e83dc6cd64?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</description></item><item><title>golang中的context</title><link>/post/context_in_golang/</link><pubDate>Tue, 27 Apr 2021 00:00:44 +0800</pubDate><guid>/post/context_in_golang/</guid><description>Reference: goroutine如何退出: https://geektutu.com/post/hpg-exit-goroutine.html context包解析: https://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;mid=2247486310&amp;idx=1&amp;sn=e1d998f35293e1bf259bf51f2f7ef6bd&amp;scene=21#wechat_redirect</description></item><item><title>golang中的defer</title><link>/post/defer_in_golang/</link><pubDate>Fri, 02 Apr 2021 01:01:00 +0800</pubDate><guid>/post/defer_in_golang/</guid><description>Reference defer分析: https://studygolang.com/articles/742 defer实现原理: https://segmentfault.com/a/1190000020614493 defer优化: https://zhuanlan.zhihu.com/p/401339057 deferreturn函数: https://www.modb.pro/db/88823</description></item><item><title>golang中的error</title><link>/post/error_in_goalng/</link><pubDate>Fri, 02 Apr 2021 01:01:00 +0800</pubDate><guid>/post/error_in_goalng/</guid><description>Reference wrapp error解析: https://studygolang.com/articles/23346?fr=sidebar</description></item><item><title>golang中的select</title><link>/post/select_in_golang/</link><pubDate>Fri, 02 Apr 2021 00:00:44 +0800</pubDate><guid>/post/select_in_golang/</guid><description>Reference: select关键字: https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/</description></item><item><title>golang哈希表</title><link>/post/hashmap_in_golang/</link><pubDate>Wed, 31 Mar 2021 01:01:00 +0800</pubDate><guid>/post/hashmap_in_golang/</guid><description>Reference 理解Golang哈希表的原理： https://juejin.cn/post/6844903793927143438 golang哈希表： https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/ golang的for-range(哈希表的遍历): https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-for-range/</description></item><item><title>一道关于gorotine的死锁问题</title><link>/post/deadlock_in_goroutine/</link><pubDate>Mon, 18 Jan 2021 21:05:24 +0800</pubDate><guid>/post/deadlock_in_goroutine/</guid><description>一道关于goroutine死锁 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { ch := make(chan int) go fmt.Println(&amp;lt;-ch) ch &amp;lt;- 5 time.Sleep(2 * time.Second) } 上述结果我选择输出5，分析如下。go关键字启动一个协程A运行，从</description></item><item><title>Channel在Go中运用</title><link>/post/the_usage_of_channel_in_go/</link><pubDate>Thu, 10 Dec 2020 21:05:24 +0800</pubDate><guid>/post/the_usage_of_channel_in_go/</guid><description>basic usage of channel 使用channel发送接收 package main import &amp;#34;fmt&amp;#34; func main() { jobs := make(chan int, 5) done := make(chan bool) go func() { for { j, more := &amp;lt;-jobs if more { fmt.Println(&amp;#34;received job&amp;#34;, j) } else { fmt.Println(&amp;#34;received all jobs&amp;#34;) done &amp;lt;- true return } } }() for j := 1; j &amp;lt;= 3; j++ {</description></item><item><title>Celery笔记</title><link>/post/celerynote/</link><pubDate>Thu, 26 Nov 2020 15:57:23 +0800</pubDate><guid>/post/celerynote/</guid><description>Getting Started celery is flexible. Almost every part of Celry can be extended or used on its own, Custom pool implementations, serializers, compression schemes, logging, schedulers, consumers, producers, broker transports, and much more. celery中current_app的指向 # main.py from celery import current_app from celery import Celery cel = Celery(&amp;#34;lll&amp;#34;) cel2 = Celery(&amp;#34;bbb&amp;#34;)</description></item></channel></rss>